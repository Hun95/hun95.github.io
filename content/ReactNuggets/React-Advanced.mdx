---
title: 'React Advanced'
date: 2020-12-22 09:57:47
subtitle: '리엑트 useState, useEffect 등 고급 기술에 대해 배워봅시다.'
tags: ['react']
---

# 🚀 Overview

# 🚀 UseState가 필요한 이유

```jsx
import React from 'react';

const ErrorExample = () => {
  let title = 'random title';
  const handleClick = () => {
    title = 'hello people';
    console.log(title);
  };
  return (
    <React.Fragment>
      <h2>{title}</h2>
      <button type='button' className='btn' onClick={handleClick}>
        change title
      </button>
    </React.Fragment>
  );
};

export default ErrorExample;
```

이러한 경우에 버튼을 눌렀을 때  
handleClick 함수가 실행되면서 title = hello people로 바뀔 것 같지만
그렇지 않다. 리엑트에서는 트리거를 이용해서 리랜더링 한다.
== UseState 함수 from 'react' 꼭 {} 컬리 브레이스를 사용해야 한다.

```console
console.log(useState);
// 함수임을 알 수 있다.
console.log(useState());
// [undefined, f]
```

useState는 함수가 undefined를 제어한다
useState는 문자열, 숫자 등 뭐든 될 수 있다. boolean 이나 뭐든
useState는 배열구조다.

```console
  console.log(useState('hello world'));
      ["hello world", f]
      ["hello world", f]
  const value = useState(1)[0];
  const handler = useState(1)[1];
  console.log(value, handler);

  1 f
  1 f
```

이를 통해 useState parentheses () 안에
값을 넣으면 값, 함수가 반환됨을 알 수 있다.
그렇다면

const [value, setValue] = useState('1');
은 뭐가 반환될까?
아까 전에 undefined, f 에서 f의 역할은
undefined를 바꿔주는 역할이라고 했다.
그렇다면 방금 const에서는
value = 1 이고
setValue는 1 값을 즉 value값을 바꿔주는 함수라고 생각하면 되겠다.

```jsx
import React, { useState } from 'react';

const UseStateBasics = () => {
  // console.log(useState('hello world'));
  // const value = useState(1)[0];
  // const handler = useState(1)[1];
  // console.log(value, handler);
  const [text, setText] = useState('11');
  const handleClick = () => {
    if (text === '11') {
      setText('hello world');
    } else {
      setText('11');
    }
  };
  return (
    <React.Fragment>
      {text}
      <button className='btn' onClick={handleClick}>
        change title
      </button>
    </React.Fragment>
  );
};

export default UseStateBasics;
```

예제를 본다면
text = 11이고
setText는 text를 바꿔주는 함수다.
바꿀 때에는 setText는 useState와 동일한 기능을 한다.
text ===11 이면 text를 hello world로 바꾸고
아니면 11로 바꿔라 라는 뜻이다.

use
component name must be uppercase
must be in the function /component body
cannot call conditionally

# 🚀 useState array

```jsx
import React, { useState } from 'react';
import { data } from '../../../data';

const UseStateArray = () => {
  const [people, setPeople] = useState(data);
  const removeItem = id => {
    let newPeople = people.filter(person => person.id !== id);
    console.log(newPeople);
    setPeople(newPeople);
  };
  return (
    <>
      {people.map(person => {
        const { id, name } = person;
        return (
          <div key={id} className='item'>
            <h4>{name}</h4>
            <button onClick={() => removeItem(id)}>remove</button>
          </div>
        );
      })}
      <button className='btn' onClick={() => setPeople([])}>
        clear all
      </button>
    </>
  );
};

export default UseStateArray;
```

이 로직은 map함수를 통해 data에 값을 invoke 하고  
invoke된 값을 filter함수를 이용해 하나씩 remove하는 작업이다.

# 🚀 useState Object

```jsx
import React, { useState } from 'react';

const UseStateObject = () => {
  const [person, setPerson] = useState({
    name: 'sehun',
    age: 26,
    message: 'hello world',
  });
  const changeMessage = () => {
    setPerson({ ...person, message: 'hi' });
  };
  return (
    <>
      <h3>{person.name}</h3>
      <h3>{person.age}</h3>
      <h3>{person.message}</h3>
      <button onClick={changeMessage} type='button'>
        Change
      </button>
    </>
  );
};

export default UseStateObject;
```

...person을 통해서 person의 값을 그대로 가져오는데 message만 hi로 바꾸는 로직

# 🚀 simple counter

```jsx
import React, { useState } from 'react';

const UseStateCounter = () => {
  const [value, setValue] = useState(0);
  const reset = () => {
    setValue(0);
  };
  const complexIncrease = () => {
    setTimeout(() => {
      // setValue(value + 1);
      setValue(prevState => {
        return prevState + 1;
      });
    }, 2000);
  };
  return (
    <>
      <section style={{ margin: '4rem 0' }}>
        <h2>regular counter</h2>
        <h1>{value}</h1>
      </section>
      <button className='btn' onClick={() => setValue(value - 1)}>
        Decrease
      </button>
      <button className='btn' onClick={() => setValue(value + 1)}>
        increase
      </button>
      <button className='btn' onClick={reset}>
        reset
      </button>

      <div>
        <section style={{ margin: '4rem 0' }}>
          <h2>more complex counter</h2>
          <h1>{value}</h1>
        </section>
        <button className='btn' onClick={complexIncrease}>
          increase
        </button>
      </div>
    </>
  );
};

export default UseStateCounter;
```

카운터를 만드는 코드다
최초 value를 0으로 설정한 뒤,
setValue를 이용해 increase버튼을 누르면 +1 되게끔 setValue(value + 1 )
Decrease도 마찬가지로 하면 된다.
reset은 setValue(0) 을 통해 value를 초기화해주면 된다.

##### BUT

지금 최초의 설정대로 한다면 문제가 생긴다.  
예를들어, setTimeout 이라는 함수에

```jsx
const complexIncrease = () => {
  setTimeout(() => {
    setValue(value + 1);
  }, 2000);
};
```

이러한 상황이라면,
2초동안 아무리 complexIncrease버튼을 눌러도 카운트가 되지 않는다.  
여기서 등장한 녀석이 prevState다

setState의 명령이 들어와도 일괄적으로 처리할 수도 있고 처리를 안 할 수도 있다.

```jsx
const complexIncrease = () ={
  setTimeout(()=>{
    setValue((prevNumber) => {
      return prevNumber + 1
    })
  }, 2000)
}
```

이런식으로 setState에 props를 지정한다.
이 props는 과거의 값을 기억한다.

```jsx
const [people, setPeople] = useState(data);
const removeItem = id => {
  let newPeople = people.filter(person => person.id !== id);
  console.log(newPeople);
  setPeople(newPeople);
};
```

```jsx
const [people, setPeople] = useState(data);
const removeItem = id => {
  setPeople(oldPeople => {
    let newPeople = oldPeope.filter(person => person.id !== id);
    return newPeople;
  });
};
```

이렇게 바뀐다.  
위의 useState가 문제있음을 감지하고  
아래의 함수로 바꿀 수 있는 능력을 키워야 한다.

# 🚀 useEffect

useEffect = 사이드 이펙트

fetching data , event listner ,

useEffect = > 컴포넌트 밖에서 일한다.
// by default runs after every re-render
// cleanup function
// second parameter

hooks = useState useEffect
훅스는 if 조건문 as far as conditional 에서 사용할 수 없다.

### 조건문을 쓰고 싶으면 useEffect 안에다가 써라

### hooks의 useState set 함수도 useEffect안에서 conditional 하게 제어할 수 있다.

initial render = 처음 렌더 될 때

```jsx
useEffect(() => {}, []);
```

맨 끝에 [] 괄호가 붙으면, braket 이 붙으면
처음 랜더 시에만 useEffect가 실행된다.

braket이 없으면, 항상 render된다. 가장중요

그렇다면 처음에만 랜더되고 뭔가가 바뀌게 할 수 없을까?

[] 안에다가 원하는 useState 즉
const [value, setValue] = useState()
라면 [] 안에다가 value 값을 넣으면
value가 바뀔 때마다, ( rerendering) 될 때마다
useEffect가 실행된다.

[]를 설정하고 [] 에 값을 넣지 않는다면 처음에만 랜더링 된다는 점 꼭 기억하자

# 🚀 Clean up function

가장 중요하다 !!

useEffect를 사용했을 때는 무조건 cleanup을 해줘야 한다
왜냐하면 프로젝트가 커지면, eventlistner 가 많아질수록 mass up 되기 때문이다.
그렇기 때문에 이벤트 리스너는 최소한으로 실행시켜야 한다.

addEventlistner을 실행했으면 무조건 removeEventListner을 해줘야 한다.

```jsx
import React, { useState, useEffect } from 'react';

// cleanup function
// second argument

const UseEffectCleanup = () => {
  const [size, setSize] = useState(window.innerWidth);

  const checkSize = () => {
    setSize(window.innerWidth);
  };

  useEffect(() => {
    console.log('useEffect');
    window.addEventListener('resize', checkSize);
    return () => {
      console.log('cleanup');
      window.removeEventListener('resize', checkSize);
    };
  }, []);
  console.log('render');
  return (
    <>
      <h1>window</h1>
      <h2>{size} PX</h2>
    </>
  );
};

export default UseEffectCleanup;
```

useEffect 맨 끝 부분에 [] 를 넣으면 최초에만 useEffect가 실행된다고 했다.
useState 안에 자바스크립트가 들어가는 지는 처음 알았다..
Event Listner 을 공부를 더 해야겠다.

https://developer.mozilla.org/ko/docs/Web/Events

### 번외 scroll 이벤트

# 🚀 Multiple return

```jsx
import React, { useState, useEffect } from 'react';
const url = 'https://api.github.com/users/QuincyLarson';
const MultipleReturns = () => {
  const [isLoading, setIsLoading] = useState(true);
  const [isError, setIsError] = useState(false);
  const [user, setUser] = useState('default user');

  useEffect(() => {
    fetch(url)
      .then(resp => {
        if (resp.status >= 200 && resp.status <= 299) {
          return resp.json();
        } else {
          setIsLoading(false);
          setIsError(true);
          throw new Error(resp.statusText);
        }
      })
      .then(user => {
        const { login } = user;
        setUser(login);
        setIsLoading(false);
      })
      .catch(error => console.log(error));
  }, []);

  if (isLoading) {
    return (
      <div>
        <h1>Loading...</h1>
      </div>
    );
  }
  if (isError) {
    return (
      <div>
        <h1>Error....</h1>
      </div>
    );
  }
  return (
    <div>
      <h1>{user}</h1>
    </div>
  );
};

export default MultipleReturns;
```

코드를 보자면, 우선 api를 선언하고
fetch한 다음에 200~ 300 구간이 response인데 그렇다면 제이슨 형태로 return 해주고
아니면 loading 창을 없애고 error창을 내보낸다.
new Error(something) 을 하나 Error(something)을 하나 같다
보통 에러를 던질 때는 throw을 사용한다.
에러 안에 resp.statusText 는 에러 상태를 나타낸다.

이게 자니가고 만약에 데이터를 정상적으로 가져왔다고 치면,  
데이터를 뿌려줘야 한다.
user라는 변수안에 담는데, user.login의 정보를 가져오고 싶다.
그 다음에 setUser로 user안에 담는다
그리고 렌더링될때 나타낼 데이터를 return 안에다 작성한다.

# 🚀 short- circuit evaluation

```jsx
import React, { useState } from 'react';
// short-circuit evaluation
// ternary operator

const ShortCircuit = () => {
  const [text, setText] = useState('');
  const [isError, setIsError] = useState(false);
  // const firstValue = text || 'hello world';
  // const secondValue = text && 'hello world';

  return (
    <>
      {/* <h1>{firstValue}</h1>
      <h1>value : {secondValue}</h1> */}
      <h1>{text || 'john doe'}</h1>
      <button
        className='btn'
        onClick={() => {
          setIsError(!isError);
        }}
      >
        toggle error
      </button>
      {isError && <h1>Error ...</h1>}
      {isError ? <p>there</p> : <p>hello</p>}
    </>
  );
};

export default ShortCircuit;
```

우선은 react 내에서는 if문을 사용할 수 없다고 한다.
그렇기에 ? : => ternary operator을 이용하거나 short-circuit을 이용해서
and or 을 작성하면 된다.
여기서 신기했던 점은
현재 isError가 false인데
클릭했을 때 isError의 반댓값으로 set하는 걸 하니
toggle이 완성됐다.
setIsError에다가 true넣으면 한번누르면 고정되고
!isError을 넣으면 State의 반댓값으로 바뀐다 .

# 🚀 Show - hide

```jsx
import React, { useState, useEffect } from 'react';

const ShowHide = () => {
  const [show, setShow] = useState(false);
  return (
    <>
      <button className='btn' onClick={() => setShow(!show)}>
        Show / Hide
      </button>
      {show && <Item />}
    </>
  );
};

const Item = () => {
  const checkSize = () => {
    setSize(window.innerWidth);
  };
  const [size, setSize] = useState(window.innerWidth);
  useEffect(() => {
    window.addEventListener('resize', checkSize);
    // return () => {
    //   window.removeEventListener('resize', checkSize);
    // };
  }, []);

  return (
    <div style={{ marginTOp: '2rem' }}>
      <h1>windows</h1>
      <h2>size : {size} </h2>
    </div>
  );
};
export default ShowHide;
```

이전에는 useEffect 뒤에 [] 를 넣었을 때 resize가 되도 render가 안됐지만,
지금은 된다 이유는, resize가 토글을 눌렀을 때도 변하기 떄문이다.
그렇기 떄문에 clear function을 꼭 작성해줘야 한다.
addEventListener가 왔으면 removeEventListener 가 꼭 와야 한다.

# 🚀 Form

```jsx
import React, { useState } from 'react';
// JS
// const input = document.getElementById('myText');
// const inputValue = input.value
// React
// value, onChange

const ControlledInputs = () => {
  const handleSubmit = e => {
    console.log('hi');
  };
  return (
    <>
      <article>
        <form className='form' onSubmit={handleSubmit}>
          <div className='form-control'>
            <label htmlFor='firstName'>Name : </label>
            <input type='text' id='firstName' name='firstName' />
          </div>
          <div className='form-control'>
            <label htmlFor='firstName'>Email : </label>
            <input type='text' id='email' name='email' />
          </div>
          <button type='submit'>add Person</button>
        </form>
      </article>
    </>
  );
};

export default ControlledInputs;
```

현재 상황에서 button 을 눌러도 console.log에 뭔가가 뜨지 않는다
뜨지 않는 건 아니고 리로딩되면서 없어지는 거다.

```jsx
const handleSubmit = e => {
  e.preventDefault();
  console.log('hi');
};
```

e.preventDefault() 를 넣어주면 리로딩되는 걸 막아준다.
그렇기 때문에 console에 로그가 뜬다

```jsx
import React, { useState } from 'react';
// JS
// const input = document.getElementById('myText');
// const inputValue = input.value
// React
// value, onChange
const ControlledInputs = () => {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [people, setPeople] = useState([]);
  const handleForm = e => {
    e.preventDefault();
    if (name && email) {
      const person = { name: name, email: email };
      setPeople(people => {
        return [...people, person];
      });
      setName('');
      setEmail('');
    } else {
      alert('아직 더 입력해주세요');
    }
  };

  return (
    <>
      <form onSubmit={handleForm}>
        <div>
          <label htmlFor='email'>Email : </label>
          <input
            id='email'
            type='email'
            value={email}
            onChange={e => {
              setEmail(e.target.value);
            }}
          />
        </div>
        <div>
          <label htmlFor='name'>Name : </label>
          <input
            id='name'
            type='text'
            value={name}
            onChange={e => setName(e.target.value)}
          />
          <button type='submit' style={{ display: 'block', width: '500px' }}>
            CLick
          </button>
        </div>
        <article>
          <h2>email</h2>
          <h2>name</h2>
        </article>
      </form>
    </>
  );
};
export default ControlledInputs;
```

요건 중요하다.

우선 form input label button 을 먼저 분석해보자

form에는 onSubmit이 들어가야 제출하기가 된다.
보통 form에다 작성한다. button에다가 작성하거나 input에다가 하는 경우도 있지만,
편의상 form에다가 하는게 좋겠다.

label의 htmlFor는 input의 id와 연동된다.
라벨 htmlfor와 input id가 같으면
라벨이 인풋 옆에 붙어버린다.
인풋을 보자

type, id, name value onchange가 있다.
type은 어떤 타입인지를 정해야 된다.
텍스트면 텍스트, 이메일, tel이면 tel 비번이면 password 등등
다양한 기능을 지원한다. password같은 경우에는 시각적으로 안보이게 만들어주는 기능을 포함한다.

id는 위에서 설명했고,
name은 input의 이름이다.
자바스크립트와 연동할 때 주로 사용된다고 한다.

value는 값. useState의 구조분해 중에서 값에 해당된다.
onChange는 input이 바뀔 때, 무얼 할건지를 적어줘야 하는데
지금 상황에서는 input을 submit한 뒤에, 이벤트로부터 값을 가져와야 한다.

그리고 이름과 이메일 and 이름 두개가 채워져있을 때 서브밋이 되게 할거다
근데 person이라는 녀석은 firstName과 email을 오브젝트로 갖고 있다.
const person = {firstname, email}
이제 people이라는 배열에 객체를 넣어 줄건데,
이전 값을 그대로 유지한 채로 넣어줄거다.
[...people, person]
그다음에 input 창을 초기화 해준다.

그렇지 않으면,

alert을 띄워서 창을 다 채우라고 알려주면 된다.

# 🚀 Multiple Input (복습 필수)

현재 위에서 사용하던 방식은 각 인풋별로 useState()를 만들었다.
하지만 입력해야되는 input창이 많아질수록 관리하기 힘들어지기 때문에
일괄적으로 관리하는 방법을 제시한다.

```jsx
import React, { useState } from 'react';
// JS
// const input = document.getElementById('myText');
// const inputValue = input.value
// React
// value, onChange
// dynamic object keys

const ControlledInputs = () => {
  // const [firstName, setFirstName] = useState('');
  // const [email, setEmail] = useState('');
  // const [age, setAge] = useState('');
  const [person, setPerson] = useState({ firstName: '', email: '', age: '' });
  const [people, setPeople] = useState([]);
  const handleChange = e => {
    const name = e.target.name;
    const value = e.target.value;
    console.log(name, value);
  };

  const handleSubmit = e => {
    e.preventDefault();
  };
  return (
    <>
      <article>
        <form className='form'>
          <div className='form-control'>
            <label htmlFor='firstName'>Name : </label>
            <input
              type='text'
              id='firstName'
              name='firstName'
              value={person.firstName}
              onChange={handleChange}
            />
          </div>
          <div className='form-control'>
            <label htmlFor='email'>Email : </label>
            <input
              type='email'
              id='email'
              name='email'
              value={person.email}
              onChange={handleChange}
            />
          </div>

          <div className='form-control'>
            <label htmlFor='age'>Age : </label>
            <input
              type='text'
              id='age'
              name='age'
              value={person.age}
              onChange={handleChange}
            />
          </div>
          <button type='submit' onClick={handleSubmit}>
            add person
          </button>
        </form>
        {people.map((person, index) => {
          const { id, firstName, email } = person;
          return (
            <div className='item' key={id}>
              <h4>{firstName}</h4>
              <p>{email}</p>
            </div>
          );
        })}
      </article>
    </>
  );
};

export default ControlledInputs;
```

우선 위와 같은 코드를 볼 수 있다.

input에 value와 name property가 있다.  
onChange 안에는 handleChange라는 함수가 존재한다.  
handleChange라는 함수는 event.target.value와 e.target.name을 콘솔에 찍는다.
handleChange라는 함수가 각 input 항목에 잇기 때문에
텍스트를 input에 입력했을 때, 어떤 input창인지와 어떤 걸 입력했는지를 가져올 수 있게 된다.

dynamic object properties

```jsx
const [person, setPerson] = useState({ firstName: '', email: '', age: '' });
const [people, setPeople] = useState([]);
const handleChange = e => {
  const name = e.target.name;
  const value = e.target.value;
  setPerson({ ...person, [name]: value });
  //setPerson({..person, firstName: value})
  console.log(name, value);
};
```

// 안에 있는 것은 다이나믹 하지 않은 것이고
위의 작성된 함수는 다이나믹하게 되어 있다.

```jsx
const handleSubmit = e => {
  e.preventDefault();
  if (person.firstName && person.email && person.age) {
    const newPerson = { ...person, id: new Date().getTime().toString() };
    setPeople([...people, newPerson]);
    setPerson({ firstName: '', email: '', age: '' });
  }
};
```

handle Change 로 person이라는 객체에 입력값을 담는다.
handleSubmit으로는 만약에 입력받은 person의 창에 name email age가 다 입력됬다면,
newPerson이라는 객체를 만들어서 기존에 person값을 그대로 가져온 상태로 id를 현재 시간을 추가해준다.
Peope에도 마찬가지로 기존 값에다가 newPerson을 추가해준다.
그리고 person을 리셋한다.

사실 위 과정에서

```jsx
const handleSubmit = e => {
  e.preventDefault();
  setPeople([...people, person]);
  setPerson({ firstName: '', email: '', age: '' });
};
```

newPerson를 새로 만들어서 id값을 추가해줄 필요는 없다.

# 🚀 UseRef

```jsx
import React, { useEffect, useRef } from 'react';

// preserves value
// DOES NOT trigger re-render
// target DOM nodes/elements

const UseRefBasics = () => {
  const refContainer = useRef(null);
  const divContainer = useRef(null);
  const handleSubmit = e => {
    e.preventDefault();
    console.log(refContainer.current.value);
    console.log(divContainer.current);
  };
  useEffect(() => {
    console.log(refContainer.current);
    refContainer.current.focus();
  });
  return (
    <>
      <form className='form' onSubmit={handleSubmit}>
        <div>
          <input type='text' ref={refContainer} />
          <button type='submit'>Submit</button>
        </div>
      </form>
      <div ref={divContainer}>hello world</div>
    </>
  );
};

export default UseRefBasics;
```

useRef는 바뀌어도 렌더링되지 않는다.
